# App Router (go_router + go_router_builder)

This document explains how Moonforge configures navigation with go_router and type-safe routes generated by go_router_builder. It covers the route tree, how to navigate, how to add or change routes, and how to regenerate code.


## Overview

- The app’s router lives at: moonforge/lib/core/services/app_router.dart
- go_router_builder generates a companion file: moonforge/lib/core/services/app_router.g.dart (do not edit)
- The generated file exports:
  - $appRoutes: the route list used to initialize GoRouter
  - Typed helper mixins (e.g., _$HomeRoute), giving you:
    - location (string)
    - go(context), push<T>(context), replace(context), etc.
- The app uses a StatefulShellRoute to host 4 branches and builds the UI with LayoutShell.


## Where the router is initialized

moonforge/lib/core/services/app_router.dart:

- part 'app_router.g.dart' links the generated output.
- AppRouter.router is the global router configured with routes: $appRoutes and an errorBuilder that shows UnknownPathScreen.


## Route tree

Moonforge defines a single top-level StatefulShell with 4 branches. Paths and their typed RouteData classes:

Branch 1 — Home & Auth
- / → HomeRoute
- /login → LoginRoute
  - /login/register → RegisterRoute
  - /login/forgot → ForgotPasswordRoute

Branch 2 — Campaign
- /campaign → CampaignRoute
  - /campaign/edit → CampaignEditRoute
  - /campaign/chapter/:chapterId → ChapterRoute
    - /campaign/chapter/:chapterId/edit → ChapterEditRoute
    - /campaign/chapter/:chapterId/adventure/:adventureId → AdventureRoute
      - .../edit → AdventureEditRoute
      - .../scene/:sceneId → SceneRoute
        - .../edit → SceneEditRoute
  - /campaign/encounter/:encounterId → EncounterRoute
    - .../edit → EncounterEditRoute
  - /campaign/entity/:entityId → EntityRoute
    - .../edit → EntityEditRoute

Branch 3 — Party
- /party[?id=<query>] → PartyRootRoute (optional query parameter: id)
  - /party/:partyId → PartyRoute
    - .../edit → PartyEditRoute
    - .../member/:memberId → MemberRoute
      - .../edit → MemberEditRoute
    - .../session/:sessionId → SessionRoute
      - .../edit → SessionEditRoute

Branch 4 — Settings
- /settings → SettingsRoute


## Typed route classes and parameters

Each page is backed by a class extending GoRouteData with a generated mixin. For example:

- class HomeRoute extends GoRouteData with _$HomeRoute { const HomeRoute(); }
- class ChapterRoute extends GoRouteData with _$ChapterRoute {
  - const ChapterRoute({required this.chapterId});
  - final String chapterId;
}
- class PartyRootRoute extends GoRouteData with _$PartyRootRoute {
  - const PartyRootRoute({this.id});
  - final String? id; // Query parameter
}

The mixins give you methods for type-safe navigation. For path parameters and query parameters, use normal typed constructor parameters. Required parameters are enforced at compile time.


## Navigating (type-safe)

Examples:
- const HomeRoute().go(context)
- const LoginRoute().push(context)
- const CampaignRoute().go(context)
- const CampaignEditRoute().push(context)
- const ChapterRoute(chapterId: 'c1').go(context)
- const ChapterEditRoute(chapterId: 'c1').push(context)
- const AdventureRoute(chapterId: 'c1', adventureId: 'a2').go(context)
- const AdventureEditRoute(chapterId: 'c1', adventureId: 'a2').push(context)
- const SceneRoute(chapterId: 'c1', adventureId: 'a2', sceneId: 's3').push(context)
- const SceneEditRoute(chapterId: 'c1', adventureId: 'a2', sceneId: 's3').push(context)
- const EncounterRoute(encounterId: 'e1').go(context)
- const EncounterEditRoute(encounterId: 'e1').push(context)
- const EntityRoute(entityId: 'en1').go(context)
- const EntityEditRoute(entityId: 'en1').push(context)
- const PartyRootRoute(id: 'optionalQuery').go(context) // Query parameter
- const PartyRoute(partyId: 'p7').go(context)
- const PartyEditRoute(partyId: 'p7').push(context)
- const MemberRoute(partyId: 'p7', memberId: 'm3').go(context)
- const MemberEditRoute(partyId: 'p7', memberId: 'm3').push(context)
- const SessionRoute(partyId: 'p7', sessionId: 's99').go(context)
- const SessionEditRoute(partyId: 'p7', sessionId: 's99').push(context)
- const SettingsRoute().go(context)

Note: push<T>(context) returns a Future<T?> so you can await a result when the page pops.


## Adding or changing routes

1) Define or update a typed route class
- Create a class extending GoRouteData and mix in the generated _$YourRoute class.
- Add typed constructor parameters for any path/query parameters.
- Implement build(...) (or buildPage(...) for custom Page/transition).

2) Register the route in the typed route tree
- Locate the @TypedStatefulShellRoute in app_router.dart
- Add a TypedGoRoute<YourRoute>(path: '...') in the appropriate branch and nesting level.
- Use path parameters with :name and map them to constructor fields.

3) Generate the code
- (Run from app dir: moonforge/)
- flutter pub get
- dart run build_runner build --delete-conflicting-outputs

This creates/updates moonforge/lib/core/services/app_router.g.dart with $appRoutes and the _$YourRoute mixin.

4) Use the new typed helpers
- Import the route type and call const YourRoute(...).go(context) or .push(context).


## Custom pages and transitions (optional)

You can override buildPage(...) in your GoRouteData to return a MaterialPage, NoTransitionPage, CustomTransitionPage, etc., and access state.pageKey and other properties.


## Error handling

AppRouter is configured with an errorBuilder that shows UnknownPathScreen if a route is not found or an error occurs during resolution. You can customize this by introducing a dedicated ErrorRoute and invoking its build method in errorBuilder if needed.


## Code generation notes

- Do not edit moonforge/lib/core/services/app_router.g.dart. Modify app_router.dart annotations and run build_runner instead.
- If you see: "Target of URI hasn't been generated: 'app_router.g.dart'" or missing _$YourRoute mixins:
  - Ensure the part directive exists: part 'app_router.g.dart';
  - Run: dart run build_runner build --delete-conflicting-outputs
  - Restart your IDE analyzer if needed after generation.
- Ensure your route class mixes in the generated mixin (with _$YourRoute), not a manual name.


## Working with the stateful shell

- The top-level @TypedStatefulShellRoute builds LayoutShell via AppShellRouteData.builder(...). LayoutShell receives a StatefulNavigationShell to manage branch switching (e.g., bottom navigation or side tabs).
- Add routes inside the appropriate TypedStatefulShellBranch to place them on a specific branch.


## Development checklist

- When you change app_router.dart:
  - dart run build_runner build --delete-conflicting-outputs
  - flutter analyze
  - flutter test (if you changed logic that affects behavior)


## Troubleshooting build_runner

- If build fails due to other generators (e.g., flutter_gen colors assets), you can:
  - Verify any referenced assets exist (see pubspec.yaml flutter_gen section).
  - Run build again after fixing the asset configuration.
  - The router code will be generated by go_router_builder as long as app_router.dart compiles for source analysis.


## References

- go_router: https://pub.dev/packages/go_router
- go_router_builder: https://pub.dev/packages/go_router_builder
- StatefulShellRoute docs: https://pub.dev/documentation/go_router/latest/topics/Stateful%20Shell%20Route-topic.html
