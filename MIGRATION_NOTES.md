# Firestore ODM Removal Migration Notes

## Summary
This document describes the migration from `firestore_odm` to direct Firestore API usage. The core database architecture (Drift local-first with Firebase sync) remains unchanged and is working well.

## What Was Changed

### 1. Dependencies (pubspec.yaml)
- ✅ Removed: `firestore_odm: ^4.0.0-dev.1`
- ✅ Removed: `firestore_odm_builder: ^4.0.0-dev.1`
- ✅ Updated: `drift: ^2.19.0` → `^2.29.0`
- ✅ Updated: `drift_flutter: ^0.2.2` → `^0.2.7`
- ✅ Updated: `drift_dev: ^2.19.0` → `^2.29.0`
- ✅ Updated: `path_provider: ^2.1.1` → `^2.1.5`
- ✅ Updated: `build_runner: ^2.5.4` → `^2.9.0`

### 2. Model Annotations
Removed `@firestoreOdm` and `@DocumentIdField` annotations from all model files:
- ✅ adventure.dart
- ✅ campaign.dart
- ✅ chapter.dart
- ✅ encounter.dart
- ✅ entity.dart
- ✅ join_code.dart
- ✅ media_asset.dart
- ✅ party.dart
- ✅ player.dart
- ✅ scene.dart
- ✅ session.dart
- ✅ user.dart (including Settings and AppLocale)

### 3. Schema Files
- ✅ Simplified `lib/data/firebase/models/schema.dart` to just re-export model files
- ✅ Deleted `lib/data/firebase/models/schema.g.dart` (ODM-generated file)

### 4. ODM Wrapper
- ✅ Transformed `lib/data/firebase/odm.dart` to provide `FirebaseFirestore` instance instead of `FirestoreODM<AppSchema>`

### 5. Web Support
- ✅ Added `moonforge/web/sqlite3.wasm` (715KB) for web platform support
- ✅ `moonforge/web/drift_worker.dart` already exists and will be compiled during Flutter web build

### 6. Utility Files (Complete Refactoring)
- ✅ `lib/features/scene/utils/create_scene.dart`
- ✅ `lib/features/adventure/utils/create_adventure.dart`

## Refactoring Pattern

### Old ODM API Pattern:
```dart
final odm = Odm.instance;

// Query
final chapters = await odm.campaigns
    .doc(campaignId)
    .chapters
    .orderBy((o) => (o.order(),))
    .get();

// Get single doc
final chapter = await odm.campaigns
    .doc(campaignId)
    .chapters
    .doc(chapterId)
    .get();

// Create with auto ID
final doc = Scene(
  id: FirestoreODM.autoGeneratedId,
  // ...
);
await odm.campaigns
    .doc(campaignId)
    .chapters
    .doc(chapterId)
    .adventures
    .doc(advId)
    .scenes
    .insert(doc);
```

### New Firestore API Pattern:
```dart
final firestore = Odm.instance;

// Query
final snapshot = await firestore
    .collection('campaigns/$campaignId/chapters')
    .orderBy('order')
    .get();
final chapters = snapshot.docs
    .map((doc) => Chapter.fromJson({'id': doc.id, ...doc.data()}))
    .toList();

// Get single doc
final docSnapshot = await firestore
    .collection('campaigns/$campaignId/chapters')
    .doc(chapterId)
    .get();
final chapter = docSnapshot.exists
    ? Chapter.fromJson({'id': docSnapshot.id, ...docSnapshot.data()!})
    : null;

// Create with auto ID
final docRef = firestore
    .collection('campaigns/$campaignId/chapters/$chapterId/adventures/$advId/scenes')
    .doc();

final doc = Scene(
  id: docRef.id,
  // ...
);

await docRef.set(doc.toJson()..remove('id'));
```

### Key Differences:
1. Collection paths are strings, not type-safe accessors
2. Must manually construct model objects from `QueryDocumentSnapshot`/`DocumentSnapshot`
3. Must manually add `id` field to the JSON during deserialization
4. Use `doc().id` to generate IDs instead of `FirestoreODM.autoGeneratedId`
5. Use `.set()` instead of `.insert()`
6. Remove 'id' from JSON before setting (Firestore manages doc ID separately)

## Files Still Using ODM API

The following files import and use `odm` but have NOT been refactored yet. They follow the same patterns shown above and need similar updates:

### Core Services (8 files)
1. `lib/core/services/breadcrumb_service.dart` (8 usages)
2. `lib/core/services/entity_gatherer.dart`
3. `lib/core/providers/auth_providers.dart`
4. `lib/core/providers/app_settings_provider.dart`
5. `lib/core/widgets/quill_mention/entity_mention_service.dart`
6. `lib/core/widgets/app_state_initializer.dart`

### Feature Screens (20+ files)
- `lib/features/encounters/views/encounter_screen.dart`
- `lib/features/scene/views/scene_screen.dart`
- `lib/features/scene/views/scene_edit_screen.dart`
- `lib/features/entities/views/entity_edit_screen.dart`
- `lib/features/entities/views/entity_screen.dart`
- `lib/features/session/views/session_screen.dart`
- `lib/features/session/views/session_public_share_screen.dart`
- `lib/features/session/views/session_edit_screen.dart`
- `lib/features/adventure/views/adventure_screen.dart`
- `lib/features/adventure/views/adventure_edit_screen.dart`
- `lib/features/campaign/views/campaign_edit_screen.dart`
- `lib/features/chapter/views/chapter_edit_screen.dart`
- `lib/features/chapter/views/chapter_screen.dart`
- And potentially more...

## Recommended Approach

### Short-term (Make it Compile)
1. Apply the refactoring pattern to each file that uses ODM
2. Search and replace common patterns:
   - `odm.campaigns.doc(id).chapters` → `firestore.collection('campaigns/$id/chapters')`
   - `.orderBy((o) => (o.field(),))` → `.orderBy('field')`
   - `.orderBy((o) => (o.field(descending: true),))` → `.orderBy('field', descending: true)`
   - `.where((f) => f.field(isEqualTo: value))` → `.where('field', isEqualTo: value)`
   - `FirestoreODM.autoGeneratedId` → `firestore.collection(...).doc().id`

### Long-term (Architecture Improvement)
The current architecture has:
- ✅ Drift as local-first storage
- ✅ Sync engine for Firebase bidirectional sync
- ✅ Repositories that provide data access through Drift
- ❌ Some UI code bypassing repositories to query Firestore directly

**The proper local-first pattern is**: All UI should read from Drift via repositories, not from Firestore directly. The sync engine handles Firebase in the background.

Consider refactoring the UI code to use the existing repositories:
- `CampaignRepository` 
- `ChapterRepository`
- `AdventureRepository`
- `SceneRepository`
- `EntityRepository`
- etc.

This would make the app truly local-first and eliminate the need for direct Firestore queries in the UI layer.

## Testing After Migration

1. Run `dart pub get` to update dependencies
2. Run `dart run build_runner build --delete-conflicting-outputs` to regenerate code
3. Fix any compilation errors following the patterns above
4. Test the app on multiple platforms:
   - Native (Android/iOS/Desktop) - should use `NativeDatabase`
   - Web - should use `WasmDatabase` with `sqlite3.wasm`
5. Verify sync engine still works correctly
6. Check that web build includes required headers for optimal performance:
   - `Cross-Origin-Opener-Policy: same-origin`
   - `Cross-Origin-Embedder-Policy: require-corp`
   - These enable the fast FileSystem Access API; Drift falls back to IndexedDB without them

## Architecture Notes

### Current State
- **Local Storage**: Drift SQLite (native: file-based, web: WASM)
- **Cloud Storage**: Firebase Firestore
- **Sync**: Bidirectional via `SyncEngine` with outbox pattern
- **Data Access**: Repositories + DAOs (but some UI bypasses this)

### Drift Tables
All domain entities have Drift tables:
- campaigns, chapters, adventures, scenes
- entities, encounters, sessions
- parties, players, media_assets
- local_metas (for metadata)
- outbox_ops (for sync queue)
- storage_queue (for file uploads)

### Why Drift Is Great
- Type-safe SQL queries
- Migration support with schema versioning
- Cross-platform (native + web)
- Generates data classes and type-safe queries
- Supports complex queries, joins, transactions
- Works offline with local-first architecture

## Resources
- Drift documentation: https://drift.simonbinder.eu/
- Drift web setup: https://drift.simonbinder.eu/platforms/web/
- Cloud Firestore documentation: https://firebase.google.com/docs/firestore
